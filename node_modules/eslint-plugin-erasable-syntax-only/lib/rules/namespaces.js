import { AST_NODE_TYPES } from "@typescript-eslint/utils";
import { CachedFactory } from "cached-factory";
import { createRule } from "../utils.js";
function skipExportParent(node) {
  return node.parent.type == AST_NODE_TYPES.ExportNamedDeclaration ? node.parent : node;
}
function skipModuleParent(node) {
  return node.parent.type === AST_NODE_TYPES.TSModuleDeclaration ? node.parent : node;
}
const rule = createRule({
  create(context) {
    const hasValueStatementCache = new CachedFactory(
      (node) => !node.declare && node.id.type !== AST_NODE_TYPES.Literal && // https://github.com/typescript-eslint/typescript-eslint/issues/10486
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      node.body.body.some?.(isValueStatement)
    );
    function isValueStatement(node) {
      switch (node.type) {
        case AST_NODE_TYPES.ExportNamedDeclaration:
          return !node.declaration || isValueStatement(node.declaration);
        case AST_NODE_TYPES.TSInterfaceDeclaration:
        case AST_NODE_TYPES.TSTypeAliasDeclaration:
          return false;
        case AST_NODE_TYPES.TSModuleDeclaration:
          return hasValueStatementCache.get(node);
        default:
          return true;
      }
    }
    return {
      TSModuleDeclaration(node) {
        if (hasValueStatementCache.get(node) && skipExportParent(node).parent.type !== AST_NODE_TYPES.TSModuleBlock) {
          context.report({
            messageId: "namespace",
            node: skipModuleParent(node)
          });
        }
      }
    };
  },
  defaultOptions: [],
  meta: {
    docs: {
      description: "Avoid using TypeScript's namespaces."
    },
    messages: {
      namespace: "This namespace will not be allowed under TypeScript's --erasableSyntaxOnly."
    },
    schema: [],
    type: "problem"
  },
  name: "namespaces"
});
export {
  rule
};
